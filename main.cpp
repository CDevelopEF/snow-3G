#include <iostream>
#include <conio.h>
#include <algorithm>
#include <vector>
#include <array>

#define poly 0x20108403
/*ROT32 Shift Left del vector n , d posiciones*/
uint32_t rot32(uint32_t n, int d){
    return ((n << d) | (n >> (32 - d)));
}

using namespace std;
//S-box del Rijndael
uint8_t Sbox[256] = {0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
                    ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
                    ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
                    ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
                    ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
                    ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
                    ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
                    ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
                    ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
                    ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
                    ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
                    ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
                    ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
                    ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
                    ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
                    ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16 };

typedef struct{
    array<uint32_t, 16> lfsr;
    uint32_t R1;
    uint32_t R2;
    uint32_t V1;
    uint32_t V2;
}Snow_p;


uint32_t xtime     (uint32_t x  );
uint32_t FSM_clock (Snow_p* vctr);
uint32_t LFSR_clock(Snow_p* s, uint32_t el);
void     key_init  (Snow_p* vctr, uint32_t* key);

int main(int args, char *argv[])
{

    Snow_p init_c;
    uint32_t key[4];
    key[0] = 0x01020304;
    key[1] = 0x05060708;
    key[2] = 0x09101112;
    key[3] = 0x13141516;

    key_init(&init_c, key);

    uint32_t momentPlease = FSM_clock(&init_c);
    uint32_t keystream1 = momentPlease ^ LFSR_clock(&init_c, momentPlease);
    printf("%0.X\n", keystream1);

    return 0;
}


//Inicializacion del LFSR y FSM segun standard 64 vueltas
void key_init(Snow_p* vctr, uint32_t *key) {
    /*IV1 = IV2 = 0 standard mode */
    vctr->V1 = 0;
    vctr->V2 = 0;
    vctr->lfsr[0] = key[0] ^ vctr->V1;
    vctr->lfsr[1] = key[1];
    vctr->lfsr[2] = key[2];
    vctr->lfsr[3] = key[3] ^ vctr->V2;

    vctr->lfsr[4] = key[0] ^ 1;
    vctr->lfsr[5] = key[1] ^ 1;
    vctr->lfsr[6] = key[2] ^ 1;
    vctr->lfsr[7] = key[3] ^ 1;
    //second half
    vctr->lfsr[8]  = key[0];
    vctr->lfsr[9]  = key[1];
    vctr->lfsr[10] = key[2];
    vctr->lfsr[11] = key[3];

    vctr->lfsr[12] = key[0] ^ 1;
    vctr->lfsr[13] = key[1] ^ 1;
    vctr->lfsr[14] = key[2] ^ 1;
    vctr->lfsr[15] = key[3] ^ 1;

    int i = 0;
    while (i < 64) {
        uint32_t fsm_out = FSM_clock(vctr);
        uint32_t S_1 = xtime(vctr->lfsr[6] ^ vctr->lfsr[12] ^ vctr->lfsr[15] ^ fsm_out);
        LFSR_clock(vctr, S_1);
        i++;
    }


}

uint32_t LFSR_clock(Snow_p* s, uint32_t el) {

    uint32_t temp = s->lfsr[15];
    rotate(s->lfsr.begin(), s->lfsr.begin() + 15, s->lfsr.end());
    s->lfsr[0] = el;
    return temp;

}

/***
     The FSM_clock function receives a structure of type Snow_p, uses the first
      value of the Shift Register with linear feedback as input of the FSM
     (Finite State Machine), proceeds to Add it modulo 2^32 with R1 and xor with
      R2, the function returns the output of the FSM and updates its internal state.
***/
uint32_t FSM_clock(Snow_p *vctr) {
    //R1 and R2 are both set to zero
    vctr->R1 = 0;
    vctr->R2 = 0;

    uint32_t FSMout =   ((vctr->lfsr[0] + vctr->R1) & 0xFFFFFFFF)     ^ vctr->R2;
    uint32_t newR1 = rot32(((FSMout + vctr->R2)     & 0xFFFFFFFF), 7) ^ vctr->R1;

    vctr->R2 = (Sbox[(vctr->R1 >> 24) & 0XFF] << 24) ^
               (Sbox[(vctr->R1 >> 16) & 0xFF] << 16) ^
               (Sbox[(vctr->R1 >> 8 ) & 0xFF] << 8 ) ^
               (Sbox[(vctr->R1      ) & 0xFF]      );

    vctr->R1 = newR1;
    return FSMout;
}
//Multiplication
uint32_t xtime(uint32_t x) {
    return ((x << 1) ^ (((x >> 31) & 1) & poly));
}

